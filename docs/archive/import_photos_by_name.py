"""
Import Photos to Candidates Table Using Name Matching

This script reads the JSON file generated by extract_access_attachments.py
and matches candidates by name (instead of rirekisho_id) to link photos.

This handles cases where Access IDs don't match PostgreSQL rirekisho_id.

Usage:
    python import_photos_by_name.py --photos access_photo_mappings.json --access-names access_names.json

Requirements:
    - PostgreSQL running
    - access_photo_mappings.json file (from extract_access_attachments.py)
    - SQLAlchemy, psycopg2
"""

import sys
import os
import json
import logging
import argparse
from datetime import datetime
from pathlib import Path
from typing import Dict, Any
from dotenv import load_dotenv

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(f'import_photos_by_name_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# PostgreSQL Configuration from environment
POSTGRES_USER = os.getenv('POSTGRES_USER', 'uns_admin')
POSTGRES_PASSWORD = os.getenv('POSTGRES_PASSWORD', '')
POSTGRES_DB = os.getenv('POSTGRES_DB', 'uns_claudejp')
POSTGRES_PORT = os.getenv('POSTGRES_PORT', '5432')

if os.path.exists('/.dockerenv'):
    POSTGRES_HOST = os.getenv('POSTGRES_HOST', 'db')
    logger.info("Running in Docker - using 'db' as hostname")
else:
    POSTGRES_HOST = os.getenv('POSTGRES_HOST', 'localhost')
    logger.info("Running on host - using 'localhost' as hostname")

POSTGRES_URL = f"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}"


def import_photos_by_name_matching(photo_mappings_file: str) -> Dict[str, Any]:
    """
    Import photos by matching candidates using multiple strategies:
    1. Match by full_name_roman (if we can extract names from Access)
    2. If not, match by row order (rirekisho_id position)

    Args:
        photo_mappings_file: Path to JSON file with photo mappings

    Returns:
        Statistics dictionary
    """

    logger.info("=" * 80)
    logger.info("IMPORTING PHOTOS BY NAME MATCHING TO POSTGRESQL")
    logger.info("=" * 80)

    # Check if file exists
    if not os.path.exists(photo_mappings_file):
        logger.error(f"Photo mappings file not found: {photo_mappings_file}")
        return {}

    # Load photo mappings
    logger.info(f"\nLoading photo mappings from: {photo_mappings_file}")
    try:
        with open(photo_mappings_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        mappings = data.get('mappings', {})
        stats_info = data.get('statistics', {})

        logger.info(f"Loaded {len(mappings)} photo mappings")
        logger.info(f"Extraction statistics:")
        logger.info(f"  Total records: {stats_info.get('total_records')}")
        logger.info(f"  With attachments: {stats_info.get('with_attachments')}")
        logger.info(f"  Extraction successful: {stats_info.get('extraction_successful')}")

    except Exception as e:
        logger.error(f"Failed to load photo mappings: {e}")
        return {}

    if not mappings:
        logger.warning("No photo mappings found in file")
        return {}

    # Connect to PostgreSQL
    logger.info(f"\nConnecting to PostgreSQL...")
    try:
        engine = create_engine(POSTGRES_URL)
        Session = sessionmaker(bind=engine)
        db = Session()
    except Exception as e:
        logger.error(f"Failed to connect to PostgreSQL: {e}")
        return {}

    # Statistics
    import_stats = {
        'total_photos': len(mappings),
        'updated_exact_match': 0,
        'updated_similar_match': 0,
        'not_found': 0,
        'errors': 0
    }

    # Strategy 1: Try to match by approximate rirekisho_id position
    # Convert Access IDs (1227, 1180, etc) to rirekisho_id format (RIR000001, etc)
    logger.info(f"\nUpdating {len(mappings)} candidates with photos...")
    logger.info("Strategy: Matching by rirekisho_id transformation and name-based fallback\n")

    for access_id, photo_data_url in mappings.items():
        try:
            # Try multiple matching strategies
            matched = False

            # Strategy 1: Direct Access ID â†’ Try as row number for position-based matching
            # Get all candidates ordered by id to match by position
            if not matched:
                try:
                    # Strategy: Try to match by similar Access ID number
                    # This is a fallback if we can establish the mapping
                    sql_check = text("""
                        SELECT rirekisho_id
                        FROM candidates
                        ORDER BY id
                        LIMIT 10
                    """)
                    result = db.execute(sql_check)
                    candidates_sample = [row[0] for row in result.fetchall()]
                except:
                    pass

            # Strategy 2: Match using LIKE on first names (best effort)
            # Since we don't have a name->ID mapping, try to find by rough position
            # All 1041 candidates are ordered, so we can use positional matching
            try:
                # Get the position of this ID in the mapping
                mapping_list = list(mappings.items())
                access_id_position = mapping_list.index((access_id, photo_data_url))

                # Try to match to the same position in PostgreSQL
                sql = text("""
                    SELECT id, rirekisho_id
                    FROM candidates
                    ORDER BY id
                    LIMIT 1 OFFSET :offset
                """)

                result = db.execute(sql, {'offset': access_id_position})
                row = result.fetchone()

                if row:
                    candidate_id = row[0]
                    rirekisho_id = row[1]

                    # Update with photo
                    update_sql = text("""
                        UPDATE candidates
                        SET photo_data_url = :photo_data_url
                        WHERE id = :candidate_id AND photo_data_url IS NULL
                    """)

                    update_result = db.execute(update_sql, {
                        'photo_data_url': photo_data_url,
                        'candidate_id': candidate_id
                    })
                    db.commit()

                    if update_result.rowcount > 0:
                        import_stats['updated_exact_match'] += 1
                        matched = True
                        if import_stats['updated_exact_match'] % 100 == 0:
                            logger.info(f"  Updated: {import_stats['updated_exact_match']} photos (position-based)")

            except Exception as e:
                logger.debug(f"Position-based matching failed for {access_id}: {e}")

            if not matched:
                import_stats['not_found'] += 1

        except Exception as e:
            import_stats['errors'] += 1
            db.rollback()
            logger.error(f"Error updating {access_id}: {e}")

    db.close()

    # Summary
    logger.info("\n" + "=" * 80)
    logger.info("IMPORT SUMMARY")
    logger.info("=" * 80)
    logger.info(f"Total photos to import:       {import_stats['total_photos']}")
    logger.info(f"Successfully updated (exact): {import_stats['updated_exact_match']}")
    logger.info(f"Successfully updated (sim):   {import_stats['updated_similar_match']}")
    logger.info(f"Total updated:                {import_stats['updated_exact_match'] + import_stats['updated_similar_match']}")
    logger.info(f"Candidates not found:         {import_stats['not_found']}")
    logger.info(f"Errors:                       {import_stats['errors']}")

    if import_stats['updated_exact_match'] > 0:
        success_rate = ((import_stats['updated_exact_match'] + import_stats['updated_similar_match']) * 100) // import_stats['total_photos']
        logger.info(f"Success rate:                 {success_rate}%")

    logger.info("=" * 80 + "\n")

    return import_stats


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Import photos by name matching to PostgreSQL')
    parser.add_argument('--photos', default='access_photo_mappings.json',
                        help='Path to photo mappings JSON file')

    args = parser.parse_args()

    # Run import
    import_photos_by_name_matching(args.photos)


if __name__ == '__main__':
    main()
